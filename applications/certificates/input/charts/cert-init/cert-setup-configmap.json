{
    "apiVersion": "v1",
    "data": {
        "certificates-spoke.sh": "#!/bin/bash\n\nreadonly RED='\\033[0;31m'\nreadonly GREEN='\\033[0;32m'\nreadonly ORANGE='\\033[38;5;214m'\nreadonly NC='\\033[0m' # No Color\nreadonly RUN_DIR=$(pwd)\n\nACME_STAGING=${ACME_STAGING:-}\nACME_SERVER=https://acme-v02.api.letsencrypt.org/directory\nHOSTED_ZONE=${HOSTED_ZONE:-}\nAWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID:-}\n\nif [ ! -z \"${ACME_STAGING}\" ]; then\n    ACME_SERVER=https://acme-staging-v02.api.letsencrypt.org/directory\nfi\n\ncreate_aws_secrets() {\n    echo \"ðŸŒ´ Running create_aws_secrets...\"\n\n    oc get secret aws-creds -n kube-system -o yaml | sed 's/namespace: .*/namespace: openshift-config/' | oc -n openshift-config apply -f-\n    oc get secret aws-creds -n kube-system -o yaml | sed 's/namespace: .*/namespace: openshift-ingress/' | oc -n openshift-ingress apply -f-\n    export AWS_ACCESS_KEY_ID=$(oc get secret aws-creds -n kube-system -o template='{{index .data \"aws_access_key_id\"}}' | base64 -d)\n    if [ \"$?\" != 0 ]; then\n        echo -e \"ðŸš¨${RED}Failed - to find aws_access_key_id ?${NC}\"\n    fi\n\n    echo \"ðŸŒ´ create_aws_secrets ran OK\"\n}\n\nupdate_cert_manager() {\n\n    echo \"ðŸŒ´ Running update_cert_manager...\"\n\ncat \u003c\u003cEOF | oc apply -f-\napiVersion: operator.openshift.io/v1alpha1\nkind: CertManager\nmetadata:\n  finalizers:\n  - cert-manager-operator.operator.openshift.io/cert-manager-webhook-deployment\n  - cert-manager-operator.operator.openshift.io/cert-manager-controller-deployment\n  - cert-manager-operator.operator.openshift.io/cert-manager-cainjector-deployment\n  name: cluster\n  annotations:\n    argocd.argoproj.io/sync-wave: \"2\"\n    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true\nspec:\n  logLevel: Normal\n  managementState: Managed\n  observedConfig: null\n  operatorLogLevel: Normal\n  unsupportedConfigOverrides: null\n  controllerConfig:\n    overrideArgs:\n      - '--dns01-recursive-nameservers-only'\n      - '--dns01-recursive-nameservers=1.1.1.1:53' \nEOF\n\n    if [ \"$?\" != 0 ]; then\n      echo -e \"ðŸš¨${RED}Failed - to run update_cert_manager ?${NC}\"\n      exit 1\n    else\n      echo \"ðŸŒ´ update_cert_manager ran OK\"\n    fi\n}\n\ncreate_issuers() {\n    echo \"ðŸŒ´ Running create_issuers...\"\n\ncat \u003c\u003cEOF | oc apply -f-\napiVersion: cert-manager.io/v1\nkind: Issuer\nmetadata:\n  name: letsencrypt-api\n  namespace: openshift-config\nspec:\n  acme:\n    server: \"${ACME_SERVER}\"\n    email: \"${EMAIL}\"\n    privateKeySecretRef:\n      name: tls-secret\n    solvers:\n    - dns01:\n        route53:\n          accessKeyID: ${AWS_ACCESS_KEY_ID}\n          hostedZoneID: $(echo ${HOSTED_ZONE} | sed 's/\\/hostedzone\\///g')\n          region: ${AWS_DEFAULT_REGION}\n          secretAccessKeySecretRef:\n            name: \"aws-creds\"\n            key: \"aws_secret_access_key\"\nEOF\n\n    if [ \"$?\" != 0 ]; then\n      echo -e \"ðŸš¨${RED}Failed - to run create_issuers ?${NC}\"\n      exit 1\n    fi\n\ncat \u003c\u003cEOF | oc apply -f-\napiVersion: cert-manager.io/v1\nkind: Issuer\nmetadata:\n  name: letsencrypt-ingress\n  namespace: openshift-ingress\nspec:\n  acme:\n    server: \"${ACME_SERVER}\"\n    email: \"${EMAIL}\"\n    privateKeySecretRef:\n      name: tls-secret\n    solvers:\n    - dns01:\n        route53:\n          accessKeyID: ${AWS_ACCESS_KEY_ID}\n          hostedZoneID: $(echo ${HOSTED_ZONE} | sed 's/\\/hostedzone\\///g')\n          region: ${AWS_DEFAULT_REGION}\n          secretAccessKeySecretRef:\n            name: \"aws-creds\"\n            key: \"aws_secret_access_key\"\nEOF\n\n    if [ \"$?\" != 0 ]; then\n      echo -e \"ðŸš¨${RED}Failed - to run create_issuers ?${NC}\"\n      exit 1\n    else\n      echo \"ðŸŒ´ create_issuers ran OK\"\n    fi\n}\n\ncreate_certificates() {\n    echo \"ðŸŒ´ Running create_certificates...\"\n\ncat \u003c\u003cEOF | oc apply -f-\napiVersion: cert-manager.io/v1\nkind: Certificate\nmetadata:\n  name: api-cert\n  namespace: openshift-config\nspec:\n  isCA: false\n  commonName: \"${LE_API}\"\n  secretName: tls-api\n  dnsNames:\n  - \"${LE_API}\" \n  issuerRef:\n    name: letsencrypt-api\n    kind: Issuer\nEOF\n\n    if [ \"$?\" != 0 ]; then\n      echo -e \"ðŸš¨${RED}Failed - to run create_certificates ?${NC}\"\n      exit 1\n    fi\n\ncat \u003c\u003cEOF | oc apply -f-\napiVersion: cert-manager.io/v1\nkind: Certificate\nmetadata:\n  name: apps-cert\n  namespace: openshift-ingress\nspec:\n  isCA: false\n  commonName: \"${LE_WILDCARD}\"\n  secretName: tls-apps\n  dnsNames:\n  - \"${LE_WILDCARD}\"\n  - \"*.${LE_WILDCARD}\"\n  issuerRef:\n    name: letsencrypt-ingress\n    kind: Issuer\nEOF\n\n    if [ \"$?\" != 0 ]; then\n      echo -e \"ðŸš¨${RED}Failed - to run create_certificates ?${NC}\"\n      exit 1\n    else\n      echo \"ðŸŒ´ create_certificates ran OK\"\n    fi\n}\n\nwait_for_api_issuer() {\n    oc wait --for=condition=Ready issuer letsencrypt-api -n openshift-config\n    local i=0\n    until [ \"$?\" == 0 ]\n    do\n        echo -e \"Wait for issuer letsencrypt-api to be ready.\"\n        ((i=i+1))\n        if [ $i -gt 100 ]; then\n            echo -e \"ðŸš¨ Failed - issuer letsencrypt-api never ready?.\"\n            exit 1\n        fi\n        sleep 5\n        oc wait --for=condition=Ready issuer letsencrypt-api -n openshift-config\n    done\n}\n\nwait_for_ingress_issuer() {\n    oc wait --for=condition=Ready issuer letsencrypt-ingress -n openshift-ingress\n    local i=0\n    until [ \"$?\" == 0 ]\n    do\n        echo -e \"Wait for issuer letsencrypt-ingress to be ready.\"\n        ((i=i+1))\n        if [ $i -gt 100 ]; then\n            echo -e \"ðŸš¨ Failed - issuer letsencrypt-ingress never ready?.\"\n            exit 1\n        fi\n        sleep 5\n        oc wait --for=condition=Ready issuer letsencrypt-ingress -n openshift-ingress\n    done\n}\n\nwait_for_api_cert() {\n    local i=0\n    oc wait --for=condition=Ready certificate api-cert -n openshift-config\n    until [ \"$?\" == 0 ]\n    do\n        echo -e \"Wait for certificate api-cert to be ready.\"\n        ((i=i+1))\n        if [ $i -gt 500 ]; then\n            echo -e \"ðŸš¨ Failed - certificate api-cert never ready?.\"\n            exit 1\n        fi\n        sleep 5\n        oc wait --for=condition=Ready certificate api-cert -n openshift-config\n    done\n}\n\nwait_for_ingress_cert() {\n    local i=0\n    oc wait --for=condition=Ready certificate apps-cert -n openshift-ingress\n    until [ \"$?\" == 0 ]\n    do\n        echo -e \"Wait for certificate apps-cert to be ready.\"\n        ((i=i+1))\n        if [ $i -gt 500 ]; then\n            echo -e \"ðŸš¨ Failed - certificate apps-cert never ready?.\"\n            exit 1\n        fi\n        sleep 5\n        oc wait --for=condition=Ready certificate apps-cert -n openshift-ingress\n    done\n}\n\npatch_api_server() {\n    echo \"ðŸŒ´ Running patch_api_server...\"\n\n    PATCH='{\"spec\":{\"servingCerts\": {\"namedCertificates\": [{\"names\": [\"'${LE_API}'\"], \"servingCertificate\": {\"name\": \"tls-api\"}}]}}}'\n    oc patch apiserver cluster --type=merge -p \"${PATCH}\"\n\n    if [ \"$?\" != 0 ]; then\n      echo -e \"ðŸš¨${RED}Failed - to run patch_api_server ?${NC}\"\n      exit 1\n    else\n      echo \"ðŸŒ´ patch_api_server ran OK\"\n    fi\n}\n\npatch_ingress() {\n    echo \"ðŸŒ´ Running patch_ingress...\"\n\n    oc -n openshift-ingress-operator patch ingresscontroller default --patch '{\"spec\": { \"defaultCertificate\": { \"name\": \"tls-apps\"}}}' --type=merge\n\n    if [ \"$?\" != 0 ]; then\n      echo -e \"ðŸš¨${RED}Failed - to run patch_ingress ?${NC}\"\n      exit 1\n    else\n      echo \"ðŸŒ´ patch_ingress ran OK\"\n    fi\n}\n\ncheck_done() {\n    echo \"ðŸŒ´ Running check_done...\"\n    oc -n openshift-ingress wait certs apps-cert --for=condition=Ready --timeout=2s\n\n    if [ \"$?\" != 0 ]; then\n      echo -e \"ðŸ’€${ORANGE}Warn - check_done not ready for apps-cert, continuing ${NC}\"\n      return 1\n    else\n      echo \"ðŸŒ´ apps-cert ran OK\"\n    fi\n\n    oc -n openshift-config wait certs api-cert --for=condition=Ready --timeout=2s\n\n    if [ \"$?\" != 0 ]; then\n      echo -e \"ðŸ’€${ORANGE}Warn - check_done not ready for api-cert, continuing ${NC}\"\n      return 1\n    else\n      echo \"ðŸŒ´ api-cert ran OK\"\n    fi\n\n    patch_api_server\n    patch_ingress\n\n    return 0\n}\n\nall() {\n    if check_done; then return; fi\n\n    create_aws_secrets\n\n    update_cert_manager\n\n    create_issuers\n    wait_for_api_issuer\n    wait_for_ingress_issuer\n\n    create_certificates\n    wait_for_api_cert\n    wait_for_ingress_cert\n\n    patch_api_server\n    patch_ingress\n}\n\nprogress() {\n    cat \u003c\u003cEOF 2\u003e\u00261\nðŸŒ» Track progress using: ðŸŒ»\n\n  watch oc get co\nEOF\n}\n\n# Check for EnvVars\n[ -z \"$EMAIL\" ] \u0026\u0026 echo \"ðŸ•± Error: must supply EMAIL in env\" \u0026\u0026 exit 1\n[ -z \"$HOSTED_ZONE\" ] \u0026\u0026 echo \"ðŸ•± Error: must supply HOSTED_ZONE in env\" \u0026\u0026 exit 1\n[ -z \"$AWS_DEFAULT_REGION\" ] \u0026\u0026 echo \"ðŸ•± Error: AWS_DEFAULT_REGION not set in env\" \u0026\u0026 exit 1\n\n# set these\nLE_API=api.$(oc get dns cluster -o jsonpath='{.spec.baseDomain}')\nLE_WILDCARD=$(oc get ingress.config/cluster -o 'jsonpath={.spec.domain}')\n[ -z \"$LE_API\" ] \u0026\u0026 echo \"ðŸ•± Error: LE_API could not set\" \u0026\u0026 exit 1\n[ -z \"$LE_WILDCARD\" ] \u0026\u0026 echo \"ðŸ•± Error: LE_WILDCARD could not set\" \u0026\u0026 exit 1\n\nall\n\nprogress\necho -e \"\\nðŸŒ»${GREEN}Certificates configured OK.${NC}ðŸŒ»\\n\"\nexit 0"
    },
    "kind": "ConfigMap",
    "metadata": {
        "name": "cert-init",
        "namespace": "openshift-config"
    }
}
